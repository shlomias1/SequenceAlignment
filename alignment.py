# -*- coding: utf-8 -*-
"""alignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11EmeRxBEQoCeBdxMoWkAykuQYyVbC19D

# **חלק 2 – עימוד רצפים**

**שאלה 1**
"""

pip install biopython

from google.colab import files
from Bio import SeqIO, Align, Entrez
from itertools import combinations

def calculate_identity(alignment):
    matches = sum(a == b for a, b in zip(alignment[0], alignment[1]) if a != "-" and b != "-")
    length = min(len(alignment[0].replace("-", "")), len(alignment[1].replace("-", "")))
    return (matches / length) * 100

def pairwise_alignments(sequences):
    aligner = Align.PairwiseAligner()
    aligner.mode = "global"
    results = []
    for seq1, seq2 in combinations(sequences, 2):
        alignment = aligner.align(seq1.seq, seq2.seq)[0]  # Choose the first alignment
        identity = calculate_identity(alignment)
        results.append((seq1.description, seq2.description, identity))  # Use description instead of id
    return results

def process_fasta_file(file_path):
    with open(file_path) as file:
        return list(SeqIO.parse(file, "fasta"))

def fetch_sequences_from_genbank(accession_numbers):
    Entrez.email = "shlomiasi1@gmail.com"
    sequences = []
    for acc in accession_numbers:
        with Entrez.efetch(db="nucleotide", id=acc, rettype="fasta", retmode="text") as handle:
            seq_record = SeqIO.read(handle, "fasta")
            sequences.append(seq_record)
    return sequences

def get_most_compatible_pair(results):
    max_identity = 0
    most_compatible_pair = None
    for pair in results:
        if pair[2] > max_identity:
            max_identity = pair[2]
            most_compatible_pair = pair
    return most_compatible_pair

def main():
    print("Part A: Alignment Results")
    uploaded = files.upload()
    sequences_a = process_fasta_file("ex2_sequences_a.fasta")
    results_a = pairwise_alignments(sequences_a)
    for res in results_a:
        print(f"{res[0]} vs {res[1]}: {res[2]:.2f}% identity")
    best_results_a = get_most_compatible_pair(results_a)
    print(f"best result: {best_results_a[0]} and {best_results_a[1]}: {best_results_a[2]:.2f}% identity")

    print("\nPart B: Alignment Results")
    accession_numbers = ["AF451972", "AF176731", "X90314"]
    sequences_b = fetch_sequences_from_genbank(accession_numbers)
    results_b = pairwise_alignments(sequences_b)
    for res in results_b:
        print(f"{res[0]} VS {res[1]}: {res[2]:.2f}% identity")
    best_results_a = get_most_compatible_pair(results_b)
    print(f"best result: {best_results_a[0]} and {best_results_a[1]}: {best_results_a[2]:.2f}% identity")

if __name__ == "__main__":
    main()

"""**שאלה 2**"""

from google.colab import files
from Bio import SeqIO, Align, Entrez
from itertools import combinations

def calculate_identity(alignment):
    matches = sum(a == b for a, b in zip(alignment[0], alignment[1]) if a != "-" and b != "-")
    length = min(len(alignment[0].replace("-", "")), len(alignment[1].replace("-", "")))
    return (matches / length) * 100

def count_mutations_and_gaps(alignment):
    matches = 0
    transitions = 0
    transversions = 0
    gaps_seq1 = 0
    gaps_seq2 = 0
    transition_pairs = {'A': 'G', 'G': 'A', 'C': 'T', 'T': 'C'}
    transversion_pairs = {'A': 'C', 'A': 'T', 'C': 'A', 'C': 'G', 'G': 'C', 'G': 'T', 'T': 'A', 'T': 'G'}

    for a, b in zip(alignment[0], alignment[1]):
        a = a.upper()
        b = b.upper()
        if a != "-" and b != "-":  # Ignore gaps
            if a == b:
                matches += 1
            elif (a, b) in transition_pairs.items() or (b, a) in transition_pairs.items():
                transitions += 1
            elif (a, b) in transversion_pairs.items() or (b, a) in transversion_pairs.items():
                transversions += 1
        if a == "-":
            gaps_seq1 += 1
        if b == "-":
            gaps_seq2 += 1

    return matches, transitions, transversions, gaps_seq1, gaps_seq2

def pairwise_alignments(sequences):
    aligner = Align.PairwiseAligner()
    aligner.mode = "global"
    results = []
    for seq1, seq2 in combinations(sequences, 2):
        alignment = aligner.align(seq1.seq, seq2.seq)[0]  # Choose the first alignment
        identity = calculate_identity(alignment)
        mutations = count_mutations_and_gaps(alignment)
        results.append((seq1.description, seq2.description, identity, mutations))  # Add mutation info
    return results

def process_fasta_file(file_path):
    with open(file_path) as file:
        return list(SeqIO.parse(file, "fasta"))

def fetch_sequences_from_genbank(accession_numbers):
    Entrez.email = "shlomiasi1@gmail.com"
    sequences = []
    for acc in accession_numbers:
        with Entrez.efetch(db="nucleotide", id=acc, rettype="fasta", retmode="text") as handle:
            seq_record = SeqIO.read(handle, "fasta")
            sequences.append(seq_record)
    return sequences

def get_most_compatible_pair(results):
    max_identity = 0
    most_compatible_pair = None
    for pair in results:
        if pair[2] > max_identity:
            max_identity = pair[2]
            most_compatible_pair = pair
    return most_compatible_pair

def main():
    print("Part A: Alignment Results")
    uploaded = files.upload()
    sequences_a = process_fasta_file("ex2_sequences_a.fasta")
    results_a = pairwise_alignments(sequences_a)
    for res in results_a:
        print(f"{res[0]} vs {res[1]}: {res[2]:.2f}% identity")
        print(f"Matches: {res[3][0]}, Transitions: {res[3][1]}, Transversions: {res[3][2]}, Gaps in Seq1: {res[3][3]}, Gaps in Seq2: {res[3][4]}")
    best_results_a = get_most_compatible_pair(results_a)
    print(f"best result: {best_results_a[0]} (seq1) and {best_results_a[1]} (seq2) : {best_results_a[2]:.2f}% identity")

    print("\nPart B: Alignment Results")
    accession_numbers = ["AF451972", "AF176731", "X90314"]
    sequences_b = fetch_sequences_from_genbank(accession_numbers)
    results_b = pairwise_alignments(sequences_b)
    for res in results_b:
        print(f"{res[0]} VS {res[1]}: {res[2]:.2f}% identity")
        print(f"Matches: {res[3][0]}, Transitions: {res[3][1]}, Transversions: {res[3][2]}, Gaps in Seq1: {res[3][3]}, Gaps in Seq2: {res[3][4]}")
    best_results_b = get_most_compatible_pair(results_b)
    print(f"best result: {best_results_b[0]} (seq1) and {best_results_b[1]} (seq2) : {best_results_b[2]:.2f}% identity")

if __name__ == "__main__":
    main()

"""**שאלה 3**"""

from google.colab import files
from Bio import SeqIO, Align, Entrez
from itertools import combinations

# Function to calculate the identity of the alignment
def calculate_identity(alignment):
    matches = sum(a == b for a, b in zip(alignment[0], alignment[1]) if a != "-" and b != "-")
    length = min(len(alignment[0].replace("-", "")), len(alignment[1].replace("-", "")))
    return (matches / length) * 100

# Function to count the mutations and gaps
def count_mutations_and_gaps(alignment):
    matches = 0
    transitions = 0
    transversions = 0
    gaps_seq1 = 0
    gaps_seq2 = 0
    transition_pairs = {'A': 'G', 'G': 'A', 'C': 'T', 'T': 'C'}
    transversion_pairs = {'A': 'C', 'A': 'T', 'C': 'A', 'C': 'G', 'G': 'C', 'G': 'T', 'T': 'A', 'T': 'G'}

    for a, b in zip(alignment[0], alignment[1]):
        a = a.upper()
        b = b.upper()
        if a != "-" and b != "-":  # Ignore gaps
            if a == b:
                matches += 1
            elif (a, b) in transition_pairs.items() or (b, a) in transition_pairs.items():
                transitions += 1
            elif (a, b) in transversion_pairs.items() or (b, a) in transversion_pairs.items():
                transversions += 1
        if a == "-":
            gaps_seq1 += 1
        if b == "-":
            gaps_seq2 += 1

    return matches, transitions, transversions, gaps_seq1, gaps_seq2

def pairwise_alignments(sequences):
    aligner = Align.PairwiseAligner()
    aligner.mode = "global"

    aligner.open_gap_score = -5  # Penalty for opening a gap
    aligner.extend_gap_score = -1  # Penalty for extending a gap
    aligner.match_score = 1  # Score for a match
    aligner.mismatch_score = -1  # Penalty for a mismatch

    results = []
    for seq1, seq2 in combinations(sequences, 2):
        alignment = aligner.align(seq1.seq, seq2.seq)[0]  # Choose the first alignment
        identity = calculate_identity(alignment)
        mutations = count_mutations_and_gaps(alignment)
        results.append((seq1.description, seq2.description, identity, mutations))  # Add mutation info
    return results

def process_fasta_file(file_path):
    with open(file_path) as file:
        return list(SeqIO.parse(file, "fasta"))

def fetch_sequences_from_genbank(accession_numbers):
    Entrez.email = "shlomiasi1@gmail.com"
    sequences = []
    for acc in accession_numbers:
        with Entrez.efetch(db="nucleotide", id=acc, rettype="fasta", retmode="text") as handle:
            seq_record = SeqIO.read(handle, "fasta")
            sequences.append(seq_record)
    return sequences

def get_most_compatible_pair(results):
    max_identity = 0
    most_compatible_pair = None
    for pair in results:
        if pair[2] > max_identity:
            max_identity = pair[2]
            most_compatible_pair = pair
    return most_compatible_pair

def main():
    print("Part A: Alignment Results")
    uploaded = files.upload()
    sequences_a = process_fasta_file("ex2_sequences_a.fasta")
    results_a = pairwise_alignments(sequences_a)
    for res in results_a:
        print(f"{res[0]} vs {res[1]}: {res[2]:.2f}% identity")
        print(f"Matches: {res[3][0]}, Transitions: {res[3][1]}, Transversions: {res[3][2]}, Gaps in Seq1: {res[3][3]}, Gaps in Seq2: {res[3][4]}")
    best_results_a = get_most_compatible_pair(results_a)
    print(f"best result: {best_results_a[0]} (seq1) and {best_results_a[1]} (seq2) : {best_results_a[2]:.2f}% identity")

    print("\nPart B: Alignment Results")
    accession_numbers = ["AF451972", "AF176731", "X90314"]
    sequences_b = fetch_sequences_from_genbank(accession_numbers)
    results_b = pairwise_alignments(sequences_b)
    for res in results_b:
        print(f"{res[0]} VS {res[1]}: {res[2]:.2f}% identity")
        print(f"Matches: {res[3][0]}, Transitions: {res[3][1]}, Transversions: {res[3][2]}, Gaps in Seq1: {res[3][3]}, Gaps in Seq2: {res[3][4]}")
    best_results_b = get_most_compatible_pair(results_b)
    print(f"best result: {best_results_b[0]} (seq1) and {best_results_b[1]} (seq2) : {best_results_b[2]:.2f}% identity")

if __name__ == "__main__":
    main()